<html>

<head>
  <title>CSE 130 : Programming Assignment #4</title>

  <link rel="stylesheet" type="text/css" href="../styles.css">
</head>

<body>

<h1 align="center">CSE 130 - Programming Assignment #4</h1>
<h2 align="center">OCaml</h2>
<h3 align="center">125 points</h3>

<!--         <h2>Notes and Hints:</h2> -->
<!--         <a href="../parser_notes/">Lexer and Parser </a>, -->
<!--         <a href="../interpreter_notes/"> Interpreter </a>. -->
<!-- <a href="http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/">OCamlLex -->
<!-- Tutorial</a> -->
<!-- <a href="http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/">OCamlYacc -->
<!-- Tutorial</a> -->
<h3 align="center">
(see submission instructions <a href="#Submission Guidelines">below</a>)</h3>
<p align="center"><i>(click your browser's refresh button to ensure that you
have the most recent version)</i></p>
<h3 align="center">(<a href="pa4_faq.html">Programming Assignment #4 FAQ</a>)</h3>

<b>Note:</b>
See <a href="../misc/ocaml/info_ocaml.html"> this </a> for instructions on
starting OCaml in the ACS lab machines.
To download and install OCaml on your home machines see the
instructions <a href="http://ocaml.org/docs/install.html">here</a>.
Remember that this is only to enable you to play with the assignment
at home: the final version turned in must work on the ACS Linux machines.

While you can use windows to begin working with OCaml, the code you
turn in must be that required for the ACS Linux environment.
<!--
<hr size=5 noshade>
<h3 align="center">Integrity of Scholarship</h3>
<p>University rules on integrity of scholarship will be strictly
enforced. By completing this assignment, you implicitly agree to
abide by the UCSD Policy on Integrity of Scholarship described beginning on
page 68 of the Academic Regulations section (<a
href="http://infopath-1.ucsd.edu/catalog/pdffiles/0708_UCSD_General_Catalog.pdf">PDF</a>) of the
2007-2008 General Catalog, in particular, &quot;all academic work will be
done by the student to whom it is assigned, without unauthorized aid of any
kind.&quot;</p> <p>You are expected to do your own work on this assignment;
there are no group projects in this course. You may (and are
encouraged to) engage in general discussions with your classmates regarding
the assignment, but specific details of a solution, including the solution
itself, must always be your own work. Incidents that violate the
University's rules on integrity of scholarship will be taken seriously:
In addition to receiving a zero (0) on the assignment, students
may also face other penalties, up to and including, expulsion from the
University. Should you have any doubt about the moral and/or ethical
implications of an activity associated with the completion of this assignment,
please see the instructors.</p>
-->
<hr size=5 noshade>
<h3 align="center"><b>Code Documentation and General Requirements</b></h3>
<p>Code for all programming assignments should be <b>well
documented</b>. A working program with no comments will <b>receive
only partial credit</b>. Documentation entails writing a description
of each function/method, class/structure, as well as comments throughout
the code to explain  the program logic. Comments in OCaml are enclosed
within (* *), and may be nested.
It is understood that some of the exercises in this programming assignment
require extremely little code and will not require extensive comments.

<p>While few programming assignments pretend to mimic the &quot;real&quot;
world, they may, nevertheless, contain some of the ambiguity that exists
outside the classroom. If, for example, an assignment is amenable to
differing interpretations, such that more than one algorithm may implement
a correct solution to the assignment, it is incumbent upon the
programmer to document not only the functionality of the algorithm (and
more broadly his/her interpretation of the program requirements), but to
articulate <b>clearly</b> the reasoning behind a particular choice of
solution.</p>


<hr size=5 noshade>
<h3 align="center">Assignment Overview</h3>
<p>The overall objective of this assignment is to expose you to some
advanced features of OCaml such as higher-order functions, abstract datatypes
and modules, as well as to fully understand the notion of scoping, binding,
environments and closures, by implementing a mini-ML interpreter. 
The template for the assignment, as well as several test cases is available as a zip file <a href="pa4.zip">pa4.zip</a> that you need to download.

<p><b>Note:</b> All the solutions can be done using the purely
functional fragment of OCaml, using constructs covered in class, and most
require the use of <i>recursion</i>.
Solutions using imperative features
such as references or while loops will receive <b>no credit</b>. Feel free
to use any library functions that you want.</p>
<b>It is a good idea to start this assignment early as it is somewhat longer
than the first three assignments.</b></p>

Even though we have included sample inputs and expected outputs for each step
in the assignment, these tests <i>are not comprehensive</i>. It is possible to
pass them all and still have a lot of mistakes (which our grading will
expose). You are responsible for understanding the problems and testing other
cases to make sure your implementation is correct.


<hr size=5 noshade>
<h3 align="center">Assignment Testing and Evaluation</h3>
<p>Your functions/programs <b>must</b> compile and/or run on a <b>Linux</b> ACS machine (e.g. <tt> ieng6.ucsd.edu </tt>,
  as this is where the verification of your solutions will occur. While
  you may develop your code on any system, ensure that your code runs as
  expected on an ACS machine prior to submission.
    You should test your code in the directories from
  which the zip files (see below) will be created, as this will approximate the
  environment used for grading the assignment.</p>

  <p>Most of the points, except those for comments and style, will be <b>awarded
  automatically, by evaluating your functions against a given test suite</b>.

  In the <tt>tests</tt> directory, there is a small handful of tests.  For this project, you will use <tt>make</tt> to compile your program.
  If for some problem, you cannot get the code to compile, leave it as is with the
  <tt>raise ...</tt>, with your partial solution enclosed below as a comment.
  <b> There will be no exceptions to this rule</b>.

	If the code you submit does not compile with make, you will receive 0 for the assignment.
      </p>
<br>
<hr size=5 noshade>

<a name="Submission Guidelines"></a>
<h3 align="center">Submission Instructions</h3>

<h3>1. Create the zip file for submission</h3>
<blockquote>
  <p>Your solutions to this assignment will be stored in separate
  files under a directory called <tt>solution/</tt>, inside which you
  will place the files :
    <tt> config.make,main.ml,Makefile,nanoLex.mll,nano.ml,nanoParse.mly,rules.make,test.ml,toplevel.ml</tt>
  and there should be <b>no other files in the directory</b>.</p>

  <p>After creating and populating the directory as described above,
  create a zip file called
  <tt>&lt;LastName&gt;_&lt;FirstName&gt;_cse130_pa4.zip</tt> by going into
  the directory <tt> solution </tt> and executing
  the UNIX shell command: <br>
  <blockquote>
    <tt> zip &lt;LastName&gt;_&lt;FirstName&gt;_cse130_pa4.zip *</tt>
  </blockquote>

  You can refer to
  an <a href="LastName_FirstName_cse130_pa4.zip">example submission
  file</a> to compare with yours. Make sure that your zipped file's
  structure is the same as the example.
  </blockquote>

<h3>2. Test the zip file to check for its validity</h3>
<blockquote>
  <p>Once you've created the zip file with your solutions, you will
  use the <tt> validate_pa4</tt> program to see whether your zip
  file's structure is well-formed to be inspected by our grading
  system by executing the UNIX shell command: <br>
  <blockquote><tt> validate_pa4 &lt;LastName&gt;_&lt;FirstName&gt;_cse130_pa4.zip </tt>
  </blockquote>
  The <tt>validate_pa4</tt> program will output <tt>OK</tt> if your
  zip file is well-formed and your solution is compiled.
  Otherwise, it will output some error
  messages. Before going to step 3, make sure that your zip file
  passes <tt>validate_pa4</tt> program. <b>Otherwise
  you get a zero for the whole assignment.</b>
  If you have any trouble with
  this, refer to the instructions in step 1.
</blockquote>

<h3>3. Submit the zip file via the <tt>turnin</tt> program</h3>
<blockquote>
  <p>Once your zip file passes the validation check
  by <tt>validate_pa4</tt>, you will use the <tt> turnin_pa4</tt> program
  to submit this file for grading by going into the
  directory <tt>solution/</tt> and executing the UNIX shell
  command: <br>
  <blockquote><tt> turnin_pa4
      &lt;LastName&gt;_&lt;FirstName&gt;_cse130_pa4.zip </tt>
  </blockquote>
    </p>
  <p>
  The <tt>turnin_pa4</tt> program will provide you with a confirmation of the
  submission process; make sure that the size of the file indicated by
  <tt>turnin_pa4</tt> matches the size of your tar file. (turnin_pa4 is a thin wrapper script around the ACMS command  <tt> <a href="http://acs.ucsd.edu/info/turnin.php">turnin</a></tt> that repeats validation and ensures that the propper assignment name is passed) Note that you may submit multiple times, but your latest submission overwrites previous submissions, and will be the ONLY one we grade. If you submit before the assignment deadline, and again afterwards, we will count it as if you only submitted after the deadline.
</p>
</blockquote>

<hr size=10 noshade>


<h2>Problem #0: Review the NanoML template </h2>
<p>
In the template for NanoML, we have provided an idiomatic OCaml compiler project. The project includes many files, but the only file you will need to edit is nano.ml. 
Nano.ml contains the definitions for the NanoML language (lines 3-36), several helper functions (38-104), as well as your starter code (108-110).
To load strings and files into the NanoML language, we have provided a parser and lexer, which you do not need to modify. To build the project,
use the provided Makefile by running <tt>make</tt>. This links your code in <tt>nano.ml</tt> with the parser and lexer, and generates an executible 
OCAML interpreter in <tt>nanoml.top</tt>. The parser provides two useful functions for you: <tt>string_to_expr</tt>, which converts a string to an NanoML expression, and <tt>filename_to_expr</tt>, which does
the same for a file. For example, you should see the following behavior:
</p>

<blockquote>
  <p><tt>
    $ <font color="#FF0000">make</font><br>
<i>output from make, hopefully with no errors</i><br>
    $ <font color="#FF0000">./nanoml.top</font><br>
	NanoML <br>
<br>
	$ ./nanoml.top <br>
	        OCaml version 4.04.0<br>
<br>
# <font color="#FF0000">Main.string_to_expr "x + y";;</font><br>
- : Nano.expr = Nano.Bin (Nano.Var "x", Nano.Plus, Nano.Var "y")
<br>
# <font color="#FF0000">Main.filename_to_expr "tests/t1.ml";;</font><br>
- : Nano.expr = <br>
Nano.Bin (Nano.Bin (Nano.Const 2, Nano.Plus, Nano.Const 3), Nano.Mul,<br>
 Nano.Bin (Nano.Const 4, Nano.Plus, Nano.Const 5))
<br>

</tt></blockquote>
<p>
In the command <tt>Main.string_to_expr "x + y";;</tt>, we converted the string "x+y" to a NanoML expression. Similarly,
the command <tt>Main.filename_to_expr "tests/t1.ml";;</tt> converted the file tests/t1.ml to a NanoML expression.
As a shortcut, the makefile also produces an executible <tt>nanoml.byte</tt> which runs <tt>filename_to_expr</tt> and <tt>eval</tt> on its argument, e.g.
</p>
<blockquote>
  <p><tt>
    $ <font color="#FF0000">make</font><br>
<i>output from make, hopefully with no errors</i><br>
    $ <font color="#FF0000">./nanoml.byte tests/t1.ml</font><br>
	NanoML <br>
  <br>
	$ ./nanoml.byte tests/t1.ml <br>
	out: Error: Failure("to be written") 
<br>
</tt></blockquote>


<p>To get the expected value for a test, import the file in an OCaml session e.g. </p>
<blockquote>
  <p><tt>
	$ <font color="#FF0000">ocaml</font><br>
	        OCaml version 4.04.0<br>
	# <font color="#FF0000">#use "tests/t1.ml";;</font><br>
	- : int = 45
	</tt></p>
</blockquote>

<p>
Now that you are familiar with how to use this project, we proceed with the assignment. 
You will implement NanoML in several separate stages, each more expressive than the last. In each
problem, you will extend <tt>eval</tt> to handle more of the <tt>expr</tt> datatype. By the end of the assignment, your NanoML interpreter
will be able to run most of the code you wrote in the previous 3 programming assignments. <br>
</p>
<hr size=10 noshade>
<h2>Problem #1: NanoML basics <tt> (nano.ml) </tt></h2>
<p>
In this problem, you will start the assignment by implementing some language basics in OCaml. 
Specifically, you will extend <tt>eval</tt> to handle the following datatypes:
</p>
<h3>(a)<b> 15 points</b></h3>
<code>
  <pre>
    type binop = Plus | Minus | Mul | Div

    type expr = Const of int
	| Var of string
	| Bin of expr * binop * expr

    type value = Int of int

    type env = (string * value) list
  </pre>
</code>

<p>
Consider the types described above: <tt>binop, expr </tt> are
used to capture simple ML expressions. Each expression is either an integer
constant, a variable, or a binary operator applied to two sub-expressions.
A value is an integer, and an environment
is a list of pairs of variable names and values.
Use <tt>listAssoc </tt> to write a function
<tt> lookup: string * env -&gt; value </tt> that finds the most recent
binding for a variable (i.e. the first from the left) in the list representing the
environment.
Using this function, write a function <tt> eval : env * expr -&gt; value
</tt> that when called with the pair <tt>(evn,e)</tt> evaluates an
NanoML expression <tt> e </tt> of the above type, in the environment
<tt> evn </tt>, and raises an exception <tt> MLFailure ("variable not bound:
  x")</tt> if the expression contains an unbound variable.</p>

<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
    # <font color="#FF0000"> let evn =[("z1",Int 0);("x",Int 1);("y",Int 2);("z",Int 3);("z1",Int 4)];;
 </font><br>
val evn : (string * Nano.value) list =
  [("z1", Int 0); ("x", Int 1); ("y", Int 2); ("z", Int 3); ("z1", Int 4)]
<br>
 # <font color="#FF0000"> let e1 =Bin(Bin(Var "x",Plus,Var "y"), Minus, Bin(Var "z",Plus,Var "z1"));;
 </font><br>
val e1 : Nano.expr =
  Bin (Bin (Var "x", Plus, Var "y"), Minus, Bin (Var "z", Plus, Var "z1"))
<br>
  # <font color="#FF0000">eval (evn,e1);;</font><br>
- : Nano.value = Int 0
<br>
 # <font color="#FF0000">eval (evn,Var "p");;</font><br>
Exception: Nano.MLFailure "Variable not bound: p".
</tt></p>
</blockquote>

<h3>(b)<b> 15 points</b></h3>

<code>
  <pre>
    type binop = Plus | Minus | Mul | Div
               | Eq | Ne | Lt | Le | And | Or

    type expr = Const of int
              | True | False
              | Var of string
              | Bin of expr * binop * expr
              | If  of expr * expr * expr

    type value = Int of int
               | Bool of bool

    type env = (string * value) list
  </pre>
</code>

<p>
Add support for the binary operators <tt>=</tt>, <tt>!=</tt>, <tt>&lt;</tt>, <tt>&lt;=</tt>, <tt>&amp;&amp;</tt>, <tt>||</tt>.  This will require using the new value type <tt>Bool</tt>.  The operators <tt>=</tt> and <tt>!=</tt> should work if both operands are <tt>Int</tt> values, or if both operands are <tt>Bool</tt> values.  The operators <tt>&lt;</tt> and <tt>&lt;=</tt> are only defined for <tt>Int</tt> arguments, and <tt>&amp;&amp;</tt> and <tt>||</tt> are only defined for <tt>Bool</tt>arguments.  For all other arguments, a MLFailure exception should be raised with an appropriate error message.</p>

<p>Now implement <tt>If</tt> expressions.  Given <tt>If(p,t,f)</tt>, <tt>p</tt> should be evaluated first, and if it evaluates to true (as a <tt>Bool</tt>), then <tt>t</tt> should be evaluated, and the value of the if expression should be the value of <tt>t</tt>.  Similarly, if <tt>p</tt> evaluates to false, then <tt>f</tt> should be evaluated and the result returned.  If <tt>p</tt> does not evaluate to a <tt>Bool</tt>, a MLFailure exception should be raised with an appropriate error message.</p>

<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
    # <font color="#FF0000"> let evn =[("z1",Int 0);("x",Int 1);("y",Int 2);("z",Int 3);("z1",Int 4)];;
 </font><br>
val evn : (string * Nano.value) list =
  [("z1", Int 0); ("x", Int 1); ("y", Int 2); ("z", Int 3); ("z1", Int 4)]
<br>
 # <font color="#FF0000"> let e1 =If(Bin(Var "z1",Lt,Var "x"),Bin(Var "y",Ne,Var "z"),False);;
 </font><br>
val e1 : Nano.expr =
  If (Bin (Var "z1", Lt, Var "x"), Bin (Var "y", Ne, Var "z"), False)
<br>
  # <font color="#FF0000">eval (evn,e1);;</font><br>
- : Nano.value = Bool true
<br>
 # <font color="#FF0000">let e2 =If(Bin(Var "z1",Eq,Var "x"),Bin(Var "y",Le,Var "z"),Bin(Var "z",Le,Var "y"));;</font><br>
val e2 : Nano.expr =
  If (Bin (Var "z1", Eq, Var "x"), Bin (Var "y", Le, Var "z"),
   Bin (Var "z", Le, Var "y"))
  # <font color="#FF0000">eval (evn,e2);;</font><br>
- : Nano.value = Bool false
</tt></p>
</blockquote>

<hr size=10 noshade>
<h2>Problem #2: NanoML bindings and functions <tt> (nano.ml) </tt></h2>
<h3>(a)<b> 10 points</b></h3>
<p> Next, you will extend <tt>eval</tt> to handle let-bindings, i.e. the following datatypes: </p>

<code>
  <pre>
    type expr = ...
	| Let of string * expr * expr
	| Letrec of string * expr * expr
  </pre>
</code>
<p>
The types as shown above include "let-in"
expressions that introduce local bindings exactly as in OCaml. <tt> Let (b,e1,e2) </tt> should be
evaluated as the ML expression <tt> let b = e1 in e2 </tt>.  Similarly, <tt> Letrec (b,e1,e2) </tt>should be
evaluated as <tt> let rec b = e1 in e2 </tt>.  At this point, we do not support functions, so Let and Letrec should do the same thing.</p>

<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
    # <font color="#FF0000"> let e1 = Bin(Var "x",Plus,Var "y");;
 </font><br>
val e1 : Nano.expr = Bin (Var "x", Plus, Var "y")
<br>
 # <font color="#FF0000"> let e2 = Let("x",Const 1,Let("y",Const 2,e1));;
 </font><br>
val e2 : Nano.expr =
  Let ("x", Const 1, Let ("y", Const 2, Bin (Var "x", Plus, Var "y")))
<br>
  # <font color="#FF0000">eval ([],e2);;</font><br>
- : Nano.value = Int 3
<br>
 # <font color="#FF0000">let e3 = Let("x",Const 1,Let("y",Const 2,Let("z",e1,Let("x",Bin(Var "x",Plus,Var "z"),e1))));;
	</font><br>
	val e3 : Nano.expr =
	  Let ("x", Const 1,
	   Let ("y", Const 2,
	    Let ("z", Bin (Var "x", Plus, Var "y"),
	     Let ("x", Bin (Var "x", Plus, Var "z"), Bin (Var "x", Plus, Var "y")))))
<br>
  # <font color="#FF0000">eval ([],e3);;</font><br>
- : Nano.value = Int 6
</tt></p>
</blockquote>


<h3>(b)<b> 15 points</b></h3>
<code>
  <pre>
    type expr = ...
		| App of expr * expr
		| Fun of string * expr

    type value = ...
		   | Closure of env * string option * string * expr
  </pre>
</code>
<p> We now extend the above types so that there is an expression for function
application: <tt> App(e1,e2) </tt> corresponds to applying <tt> e2 </tt> to
the function <tt> e1 </tt>, we allow function declarations via the expression
<tt> Fun (x,e) </tt> where <tt>x</tt> and <tt>e</tt> are respectively the formal parameter and body-expression of the function.
For now, assume the function is not recursive.
However, functions do have values represented by the <tt> Closure
  (evn,f,x,e)</tt> where <tt> evn </tt> is the
environment at the point where that function was declared, and <tt> n,x,e
</tt> are name, formal and body expression of the function.  If the function is anonymous or declared in a let statement, the name should be <tt>None</tt>.  If the function is declared in a <tt>let rec</tt> statement, then the name of the function should be <tt>Some f</tt> (where f is the name of the function). <b>It is very important that you save the name of let-rec functions for the next problem.</b>
Extend your implementation of <tt> eval </tt> by adding the
appropriate cases for the new type constructors.
</p>


<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
    # <font color="#FF0000">eval ([],Fun ("x",Bin(Var "x",Plus,Var "x")));;
 </font><br>
- : Nano.value = Closure ([], None, "x", Bin (Var "x", Plus, Var "x"))
<br>
 # <font color="#FF0000">eval ([],App(Fun ("x",Bin(Var "x",Plus,Var "x")),Const 3));;
 </font><br>
- : Nano.value = Int 6
<br>
  # <font color="#FF0000">let e3=Let("h",Fun("y",Bin(Var "x", Plus, Var "y")),App(Var "f",Var "h"));;</font><br>
val e3 : Nano.expr =
  Let ("h", Fun ("y", Bin (Var "x", Plus, Var "y")), App (Var "f", Var "h"))
<br>
 # <font color="#FF0000">let e2 = Let("x",Const 100,e3);;</font><br>
val e2 : Nano.expr =
  Let ("x", Const 100,
   Let ("h", Fun ("y", Bin (Var "x", Plus, Var "y")), App (Var "f", Var "h")))
<br>
 # <font color="#FF0000">let e1 = Let("f",Fun("g",Let("x",Const 0,App(Var "g",Const 2))),e2);;</font><br>
val e1 : Nano.expr =<br>
  Let ("f", Fun ("g", Let ("x", Const 0, App (Var "g", Const 2))),<br>
   Let ("x", Const 100,<br>
    Let ("h", Fun ("y", Bin (Var "x", Plus, Var "y")),<br>
     App (Var "f", Var "h"))))
<br>
  # <font color="#FF0000">eval ([],e1);;</font><br>
- : Nano.value = Int 102
<br>
# <font color="#FF0000">eval ([],Letrec("f",Fun("x",Const 0),Var "f"));;</font><br>
- : Nano.value = Closure ([], Some "f", "x", Const 0)
</tt></p>
</blockquote>

<h3>(c)<b> 15 points</b></h3>
<p>Make the above work for recursively defined functions (when declared with <tt>let rec</tt>). The key to recursive functions is that
	their evaluation environment in the <tt>App</tt> needs a binding for the function's own name. Use the <tt>Some name</tt> field of the <tt>Closure</tt> datatype
	to properly handle recursive functions in the <tt>App</tt> rule.
</p>

<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
    # <font color="#FF0000">eval ([],Letrec("fac",Fun("n",If(Bin(Var "n",Eq,Const 0),Const 1,Bin(Var "n",Mul,App(Var "fac",Bin(Var "n",Minus,Const 1))))),App(Var "fac",Const 10)));;</font><br>
	- : Nano.value = Int 3628800
</tt>
</blockquote>

<h2>Problem #3: NanoML lists <tt> (nano.ml) </tt></h2>
<p>
Finally, you will add language support for lists to NanoML. You will start with the basic operations for representing and building lists:</p>
<h3>(a)<b> 10 points</b></h3>
<code>
  <pre>
	  type binop = ...
	            | Cons

    type expr = ...
              | NilExpr

    type value = ...
               | Nil
               | Pair of value * value
  </pre>
</code>

<p>
Extend your program to support basic list operations. We use <tt>Cons</tt> and <tt>NilExpr</tt> to represent OCaml's <tt>::</tt> operator and <tt>[]</tt> expression. 
At runtime, the value of a list is either empty (<tt>Nil</tt>) or a pair of the element and the tail (i.e. <tt>element::tail</tt> -- this is known as a <i>cons cell</i>). </p>

<p>Once you have implemented this functionality and recompiled, you should get the following behavior at the <tt>./nanoml.top</tt> prompt:</p>

<blockquote>
  <p><tt>
	# <font color="#FF0000">open Nano;;</font><br>
		# <font color="#FF0000">eval ([],NilExpr);;</font><br>
				- : Nano.value = Nil
			<br>
    # <font color="#FF0000">eval ([],Bin(Const 1,Cons,Bin(Const 2,Cons,NilExpr)));;</font><br>
	- : Nano.value = Pair (Int 1, Pair (Int 2, Nil))
<br>
</tt></p>
</blockquote>

<h3>(b)<b> 15 points</b></h3>
<p>You will next implement several fundamental list-processing functions: <tt>hd</tt>, <tt>tl</tt>, and <tt>null</tt>.
<tt>hd</tt> takes a nonempty list as input and returns the first element -- if its argument is empty, or not a list, it throws an error.
<tt>tl</tt> takes a nonempty list as input and returns the remainder -- if its argument is empty, or not a list, it throws an error.
<tt>null</tt> tests a list for whether the list is empty or nonempty -- if its argument is not a list, it throws an error.
</p>

<p> You will implement this functionality by using the <tt>NativeFunc</tt> case of <tt>value</tt>:
<code>
  <pre>
    type value = ...
		| NativeFunc of string
  </pre>
</code>
</p>

<p>Whenever a native function is used as a variable, you should return a value with that function's name, for example:</p>

<blockquote>
		<p><tt>
		# <font color="#FF0000">open Nano;;</font><br>
			# <font color="#FF0000">eval ([],Var "hd");;</font><br>
					- : Nano.value = NativeFunc "hd"
				<br>
	<br>
		</tt></p>
</blockquote>

<p>Then, when a native function is applied in an <tt>App</tt> rule, you should return the behavior corresponding to that function, for example:</p>
<blockquote>
		<p><tt>
		# <font color="#FF0000">open Nano;;</font><br>
			# <font color="#FF0000">eval ([],App(Var "hd",Bin(Const 1,Cons,Bin(Const 2,Cons,NilExpr))));;</font><br>
			- : Nano.value = Int 1
			<br>
			# <font color="#FF0000">eval ([],App(Var "tl",Bin(Const 1,Cons,Bin(Const 2,Cons,NilExpr))));;</font><br>
			- : Nano.value = Pair (Int 2, Nil) <br>
			# <font color="#FF0000">eval ([],App(Var "null",NilExpr));;</font><br>
			- : Nano.value = Bool True <br>
	<br>
		</tt></p>
</blockquote>

<h3>(c)<b> 15 points</b></h3>
<p>Finally, you will implement several higher-order list functions: <tt>map</tt> and <tt>foldl</tt>.
<tt>map</tt> takes a function as input and a list as (curried) inputs and applies the function to each element of the list. This is OCaml's <tt>List.map</tt>.
<tt>foldl</tt> takes a function, initial value, and list as (curried) inputs and reduces the list using the function and initial value. This is Ocaml's <tt>List.fold_left</tt>.
As always, if either <tt>map</tt> or <tt>foldl</tt> are passed ill-typed inputs, it should result in a <tt>MLFailure</tt>. However, the error message does not have to be specific to map or foldl, and if an 
ill-typed expression is never fully evaluated, for example <tt>foldl (fun x -> x + 1) true</tt>, you do not need to throw an exception.
</p>

<p>We recommend that you use your existing list primitives to implement NanoML versions of map and foldl -- for a hint, see tests/t11.ml and tests/t12.ml. Then, when the interpreter sees
	a <tt>map</tt> or <tt>foldl</tt> variable, it returns the saved library version.
</p>

<p>After you have implemented this portion, you should see the following behavior:</p>

<blockquote>
		<p><tt>
		# <font color="#FF0000">open Nano;;</font><br>
			# <font color="#FF0000">eval ([],Main.string_to_expr "map (fun x -> x + 1) 1::2::3::[]");;</font><br>
			- : Nano.value = Pair(Int 2, Pair(Int 3, Pair (Int 4, Nil))
			<br>
			# <font color="#FF0000">eval ([],Main.string_to_expr "foldl (fun acc -> fun next -> acc + next) 0 1::2::3::[]");;</font><br>
			- : Nano.value = Int 6 <br>
	<br>
		</tt></p>
</blockquote>



<hr size=10 noshade>
<h2>Problem #4: NanoML executable</h2>

<p>Once you have completed all the above parts, you should end up with an executable "nanoml.byte".  You should be able to test it as follows from the shell prompt:</p>

<blockquote>
  <p><tt>
	$ <font color="#FF0000">./nanoml.byte tests/t1.ml</font><br>
	...<br>
	out: 45
	<br>
	$ <font color="#FF0000">./nanoml.byte tests/t2.ml</font><br>
	...<br>
	out: 0
	<br>
	$ <font color="#FF0000">./nanoml.byte tests/t3.ml</font><br>
	...<br>
	out: 2
	<br>
</tt></p>
</blockquote>

and so forth, for all the files in tests.  To get the expected value for the other tests, run them with ocaml:

<blockquote>
  <p><tt>
	# <font color="#FF0000">#use "tests/t1.ml";;</font><br>
	- : int = 45
	</tt></p>
</blockquote>

<hr size=10 noshade>
<h2>If the code you submit does not get passed by <tt>validate_pa4</tt> or submitted by <tt>turnin_pa4</tt>, you will get 0 for the assignment.</h2>

</body>

</html>
